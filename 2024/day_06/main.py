import time
from typing import Optional

# courtesy of tinygrad <3
def colored(st, color:Optional[str], background=False): return f"\u001b[{10*background+60*(color.upper() == color)+30+['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'].index(color.lower())}m{st}\u001b[0m" if color is not None else st  # replace the termcolor library with one line  # noqa: E501

def cycle_dir(dir):
    dirs = "^>v<"
    curr_dir_idx = dirs.index(dir)
    return dirs[(curr_dir_idx + 1) % len(dirs)]


def action(guard_state, grid):
    # action by guard + grid update
    curr_pos = guard_state["pos"]
    curr_dir = guard_state["dir"]
    
    dirs = {
        "^": (-1, 0), # up
        ">": (0, 1),  # right
        "v": (1, 0),  # down
        "<": (0, -1)  # left
    }
    move = dirs[curr_dir]
    
    # attempt to move the guard from current position
    proposed_pos = tuple(curr_pos[i] + move[i] for i in [0, 1])

    cell_state = grid[proposed_pos[0]][proposed_pos[1]]
    if cell_state == "#":
        # obstacle in way, rotate 90 degrees
        guard_state["dir"] = cycle_dir(curr_dir)
    elif cell_state == "-":
        # guard out of bounds - end condition
        guard_state["done"] = True
    else:
        # path is clear, move forward one spot
        guard_state["pos"] = proposed_pos
    
    # update the guard position on the grid
    grid = update_grid(curr_pos, guard_state, grid)
    return guard_state, grid

    
def update_grid(prev_pos, guard_state, grid):
    # we can't directly update a pos in string, i.e., "str"[1] = "!"
    # so we have to convert the string into a list of chars, update the 
    # the index, and then join the char list into a single string again

    # update the prev pos row
    old_row = list(grid[prev_pos[0]]) # list of chars
    old_row[prev_pos[1]] = "." # replace the col in the row
    grid[prev_pos[0]] = "".join(old_row) # join the chars back as str

    # update the new pos row
    curr_pos = guard_state["pos"]
    curr_dir = guard_state["dir"]
    new_row = list(grid[curr_pos[0]]) # list of chars
    new_row[curr_pos[1]] = curr_dir # replace the col in the row
    grid[curr_pos[0]] = "".join(new_row) # join the chars back as str
    return grid


def print_grid(grid, trajectory, delay=0.2):
    # generated by gpt 4o (i made the basic print functionality)
    color_map = {
        "#": "red",      # Obstacles
        "^": "blue",     # Guard facing up
        ">": "green",    # Guard facing right
        "v": "cyan",     # Guard facing down
        "<": "yellow",   # Guard facing left
        ".": "white",    # Path
        "-": None,       # Borders (no color)
        "trail": "magenta"  # Trail of visited positions
    }
    
    # Clear the terminal
    print("\033[H\033[J", end="")  # ANSI escape code to clear the screen

    for i, line in enumerate(grid):
        colored_line = ""
        for j, char in enumerate(line):
            # If the position is in the trajectory and not the guard's current position, color it as a trail
            if (i, j) in trajectory and char not in "^>v<":
                colored_line += colored(".", color_map["trail"])
            else:
                colored_line += colored(char, color_map.get(char, "white"))
        print(colored_line)
    
    time.sleep(delay)  # Pause for the specified duration


def task_one(input):
    """
    Given a map with obstacles, determine the number of unique
    positions a guard will walk. The guard follows two rules:
    1) if path unobstructed, walk forward, 2) otherwise, 
    rotate 90 degrees clockwise. guard has states ^, >, v, <
    """
    # first we'll just add some padding around the grid to 
    # make checking the literal edge cases (end condition) easier
    grid = []
    for line in input:
        grid.append("-" + line + "-")
    top_bottom = ["-" * len(grid[0])]
    grid = top_bottom + grid + top_bottom
    # print("grid size:", (len(grid), len(grid[0])))

    guard_state = {
        "dir": "^",
        "pos": -1,
        "done": False
    }
    
    # find starting point - guard starts pointing up ^
    for i in range(len(input)):
        for j in range(len(input[0])):
            if grid[i][j] == "^":
                guard_state["pos"] = (i, j)
                break
    
    # set to store unique points
    trajectory = {guard_state["pos"]} 
    while guard_state["done"] == False:
        print_grid(grid, trajectory) # best to use with demo puzzle
        guard_state, grid = action(guard_state, grid)
        trajectory.add(guard_state["pos"]) 
    return len(list(trajectory))



def task_two(input):
    ...

if __name__ == "__main__":
    with open("input.txt", "r") as f:
        input = [line.strip() for line in f.readlines()]

    task1 = task_one(input)
    print(f"task 1: {task1}")

    task2 = task_two(input)
    print(f"task 2: {task2}")

